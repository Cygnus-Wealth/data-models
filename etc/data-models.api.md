## API Report File for "@cygnus-wealth/data-models"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export interface Account {
    balances: Balance[];
    id: string;
    lastSynced?: Date;
    lendingPositions?: LendingPosition[];
    liquidityPositions?: LiquidityPosition[];
    metadata?: Metadata;
    name: string;
    nfts?: NFT[];
    source: IntegrationSource;
    sourceAccountId?: string;
    stakedPositions?: StakedPosition[];
    totalValue?: Price;
    type: AccountType;
    vaultPositions?: VaultPosition[];
}

// @public
export interface AccountAssetEntry {
    accountId: AccountId;
    accountLabel: string;
    connectionLabel: string;
    percentage: number;
    quantity: Balance;
    value: Price;
}

// @public
export interface AccountBalance {
    accountId: AccountId;
    address: string;
    chainId: Chain;
    nativeBalance: Balance;
    tokenBalances: Balance[];
}

// @public
export interface AccountBalanceList {
    balances: AccountBalance[];
    errors: AccountError[];
    timestamp: string;
}

// @public
export interface AccountError {
    accountId: AccountId;
    chainId: Chain;
    code?: string;
    message: string;
}

// @public
export interface AccountGroup {
    accountIds: AccountId[];
    createdAt: string;
    groupId: string;
    groupName: string;
}

// @public
export type AccountId = string;

// @public
export interface AccountMetadata {
    accountId: AccountId;
    accountLabel: string;
    address: string;
    connectionLabel: string;
    discoveredAt: string;
    groups: string[];
    isActive: boolean;
    isStale: boolean;
    providerId: WalletProviderId | 'watch';
    walletConnectionId: WalletConnectionId | 'watch';
}

// @public
export interface AccountPortfolio {
    accountId: AccountId;
    accountLabel: string;
    assets: Asset[];
    lastUpdated: string;
    providerName: string;
    totalValue: Price;
    walletConnectionId: WalletConnectionId | 'watch';
}

// @public
export interface AccountSummary {
    accountId: AccountId;
    accountLabel: string;
    assetCount: number;
    chains: Chain[];
    connectionLabel: string;
    lastUpdated: string;
    providerId: WalletProviderId | 'watch';
    totalValue: Price;
}

// @public
export enum AccountType {
    BROKERAGE = "BROKERAGE",
    DEFI = "DEFI",
    FUTURES = "FUTURES",
    MARGIN = "MARGIN",
    OTHER = "OTHER",
    RETIREMENT = "RETIREMENT",
    SAVINGS = "SAVINGS",
    SPOT = "SPOT",
    STAKING = "STAKING",
    WALLET = "WALLET"
}

// @public
export interface AddressRequest {
    accountId: AccountId;
    address: string;
    chainScope: Chain[];
}

// @public
export interface ApiError {
    code: string;
    details?: unknown;
    message: string;
}

// @public
export interface ApiResponse<T extends object> {
    data?: T;
    error?: ApiError;
    success: boolean;
    timestamp: Date;
}

// @public
export interface Asset {
    accountId?: AccountId;
    chain?: Chain;
    cmc_id?: string;
    coingeckoId?: string;
    contractAddress?: string;
    cusip?: string;
    decimals?: number;
    id: string;
    isin?: string;
    logoUrl?: string;
    metadata?: Metadata;
    name: string;
    symbol: string;
    type: AssetType;
    walletConnectionId?: WalletConnectionId | 'watch';
}

// @public
export interface AssetDistribution {
    distribution: AccountAssetEntry[];
    symbol: string;
    totalQuantity: Balance;
    totalValue: Price;
}

// @public
export type AssetIdentifier = {
    symbol?: string;
    contractAddress?: string;
    chain?: Chain;
    assetId?: string;
};

// @public
export enum AssetType {
    BOND = "BOND",
    COMMODITY = "COMMODITY",
    CRYPTOCURRENCY = "CRYPTOCURRENCY",
    DERIVATIVE = "DERIVATIVE",
    ETF = "ETF",
    FIAT = "FIAT",
    LENDING_POSITION = "LENDING_POSITION",
    LIQUIDITY_POOL = "LIQUIDITY_POOL",
    MUTUAL_FUND = "MUTUAL_FUND",
    NFT = "NFT",
    OTHER = "OTHER",
    STAKED_POSITION = "STAKED_POSITION",
    STOCK = "STOCK"
}

// @public
export interface Balance {
    amount: string;
    asset: Asset;
    assetId: string;
    cost_basis?: number;
    metadata?: Metadata;
    realized_pnl?: number;
    unrealized_pnl?: number;
    value?: Price;
}

// @public
export interface BaseEntity {
    createdAt: Date;
    id: string;
    updatedAt: Date;
}

// @public
export enum Chain {
    ARBITRUM = "ARBITRUM",
    AVALANCHE = "AVALANCHE",
    BASE = "BASE",
    BITCOIN = "BITCOIN",
    BSC = "BSC",
    ETHEREUM = "ETHEREUM",
    OPTIMISM = "OPTIMISM",
    OTHER = "OTHER",
    POLYGON = "POLYGON",
    SOLANA = "SOLANA",
    SUI = "SUI"
}

// @public
export interface ChainRpcConfig {
    cacheStaleAcceptanceMs: number;
    chainId: number;
    chainName: string;
    endpoints: RpcEndpointConfig[];
    totalOperationTimeoutMs: number;
}

// @public
export interface CircuitBreakerConfig {
    failureThreshold: number;
    halfOpenMaxAttempts: number;
    monitorWindowMs: number;
    openDurationMs: number;
}

// @public
export interface ConnectedAccount {
    accountId: AccountId;
    accountLabel: string;
    address: string;
    chainScope: Chain[];
    discoveredAt: string;
    isActive: boolean;
    isStale: boolean;
    source: 'provider' | 'manual';
}

// @public
export enum DeFiDiscoverySource {
    CONTRACT_QUERY = "CONTRACT_QUERY",
    WALLET_TOKEN_SCAN = "WALLET_TOKEN_SCAN"
}

// @public
export interface DeFiPosition {
    accountId?: AccountId;
    apy?: number;
    chain: Chain;
    discoverySource?: DeFiDiscoverySource;
    id: string;
    metadata?: Metadata;
    protocol: DeFiProtocol;
    rewards: Balance[];
    type: DeFiPositionType;
    underlyingAssets: Balance[];
    value?: Price;
}

// @public
export enum DeFiPositionType {
    FARMING = "FARMING",
    LENDING_BORROW = "LENDING_BORROW",
    LENDING_SUPPLY = "LENDING_SUPPLY",
    LIQUIDITY_POOL = "LIQUIDITY_POOL",
    PERP_POSITION = "PERP_POSITION",
    STAKING = "STAKING",
    VAULT = "VAULT"
}

// @public
export enum DeFiProtocol {
    AAVE = "AAVE",
    BEEFY = "BEEFY",
    COMPOUND = "COMPOUND",
    JUPITER = "JUPITER",
    LIDO = "LIDO",
    MARINADE = "MARINADE",
    ORCA = "ORCA",
    OTHER = "OTHER",
    RAYDIUM = "RAYDIUM",
    UNISWAP = "UNISWAP"
}

// @public
export interface EnvironmentConfig {
    chain: Chain;
    environment: NetworkEnvironment;
    label?: string;
    rpcUrl: string;
}

// @public
export interface FilterOptions {
    accountIds?: AccountId[];
    assetTypes?: AssetType[];
    chains?: Chain[];
    groupIds?: string[];
    maxValue?: number;
    minValue?: number;
    sources?: IntegrationSource[];
    timeRange?: TimeRange;
    walletConnectionIds?: WalletConnectionId[];
}

// @public
export interface GroupPortfolio {
    accounts: AccountPortfolio[];
    groupId: string;
    groupName: string;
    lastUpdated: string;
    totalValue: Price;
}

// @public
export interface HealthCheckConfig {
    intervalMs: number;
    method: string;
    timeoutMs: number;
}

// @public
export interface IntegrationCredentials {
    accountId?: AccountId;
    apiKey?: string;
    apiSecret?: string;
    chainId?: string;
    metadata?: Metadata;
    passphrase?: string;
    source: IntegrationSource;
    walletAddress?: string;
}

// @public
export enum IntegrationSource {
    BALANCER = "BALANCER",
    BINANCE = "BINANCE",
    BLOCKCHAIN_DIRECT = "BLOCKCHAIN_DIRECT",
    COINBASE = "COINBASE",
    CURVE = "CURVE",
    KRAKEN = "KRAKEN",
    MANUAL_ENTRY = "MANUAL_ENTRY",
    METAMASK = "METAMASK",
    OTHER = "OTHER",
    PANCAKESWAP = "PANCAKESWAP",
    PHANTOM = "PHANTOM",
    RABBY = "RABBY",
    ROBINHOOD = "ROBINHOOD",
    SLUSH = "SLUSH",
    SUIET = "SUIET",
    SUSHISWAP = "SUSHISWAP",
    UNISWAP = "UNISWAP"
}

// @public
export interface LendingPosition {
    accruedInterest?: number;
    amount: string;
    apy?: number;
    asset: Asset;
    chain: Chain;
    discoverySource?: DeFiDiscoverySource;
    healthFactor?: number;
    id: string;
    liquidationThreshold?: number;
    metadata?: Metadata;
    protocol: string;
    type: LendingPositionType;
    value?: Price;
}

// @public
export enum LendingPositionType {
    BORROW = "BORROW",
    SUPPLY = "SUPPLY"
}

// @public
export interface LiquidityPosition {
    chain: Chain;
    discoverySource?: DeFiDiscoverySource;
    feesEarned?: number;
    id: string;
    impermanentLoss?: number;
    lpTokenBalance?: string;
    metadata?: Metadata;
    poolAddress: string;
    poolName: string;
    protocol: string;
    share?: number;
    tokens: Balance[];
    value?: Price;
}

// @public
export interface MarketData {
    assetId: string;
    circulatingSupply?: number;
    currentPrice: Price;
    high24h?: number;
    lastUpdated: Date;
    low24h?: number;
    marketCap?: number;
    priceChange24h?: number;
    priceChangePercentage24h?: number;
    totalSupply?: number;
    volume24h?: number;
}

// @public
export interface Metadata {
    [key: string]: unknown;
}

// @public
export type NetworkEnvironment = 'production' | 'testnet' | 'local';

// @public
export interface NFT extends Asset {
    animationUrl?: string;
    attributes?: Array<{
        trait_type: string;
        value: string | number;
        display_type?: string;
    }>;
    collectionAddress: string;
    collectionName: string;
    imageUrl?: string;
    tokenId: string;
    tokenUri?: string;
}

// @public
export interface PaginatedResponse<T> {
    hasMore: boolean;
    items: T[];
    page: number;
    pageSize: number;
    total: number;
}

// @public
export interface Portfolio {
    accountBreakdown?: Map<AccountId, AccountPortfolio>;
    accounts?: Account[];
    id: string;
    items?: PortfolioAsset[];
    lastUpdated: Date;
    metadata?: Metadata;
    name: string;
    performance?: {
        day: number;
        week: number;
        month: number;
        year: number;
        all_time: number;
    };
    totalValue: Price;
    totalValueHistory?: Array<{
        timestamp: Date;
        value: Price;
    }>;
    userId?: string;
    walletBreakdown?: Map<WalletConnectionId, WalletPortfolio>;
}

// @public
export interface PortfolioAsset {
    accountId: string;
    allocation: number;
    asset: Asset;
    assetId: string;
    balance: Balance;
    id: string;
    lastUpdated: Date;
    value: Price;
}

// @public @deprecated
export interface PortfolioItem {
    balance: number;
    id: string;
}

// @public
export interface Price {
    amount?: number;
    currency: string;
    source?: IntegrationSource;
    timestamp: Date;
    value?: number;
}

// @public
export interface PrivacyConfig {
    privacyMode: boolean;
    queryJitterMs: number;
    rotateWithinTier: boolean;
}

// @public
export interface RetryConfig {
    baseDelayMs: number;
    maxAttempts: number;
    maxDelayMs: number;
}

// @public
export interface RpcEndpointConfig {
    provider: string;
    rateLimitRps: number;
    role: RpcProviderRole;
    timeoutMs: number;
    type: RpcProviderType;
    url: string;
    weight?: number;
    wsUrl?: string;
}

// @public
export interface RpcProviderConfig {
    chains: Record<string, ChainRpcConfig>;
    circuitBreaker: CircuitBreakerConfig;
    healthCheck: HealthCheckConfig;
    privacy: PrivacyConfig;
    retry: RetryConfig;
    userOverrides?: UserRpcConfig;
}

// @public
export enum RpcProviderRole {
    EMERGENCY = "EMERGENCY",
    PRIMARY = "PRIMARY",
    SECONDARY = "SECONDARY",
    TERTIARY = "TERTIARY"
}

// @public
export enum RpcProviderType {
    COMMUNITY = "COMMUNITY",
    DECENTRALIZED = "DECENTRALIZED",
    MANAGED = "MANAGED",
    PUBLIC = "PUBLIC",
    USER = "USER"
}

// @public
export type SortOrder = 'ASC' | 'DESC';

// @public
export interface StakedPosition {
    apr?: number;
    asset: Asset;
    chain: Chain;
    discoverySource?: DeFiDiscoverySource;
    id: string;
    lockupPeriod?: number;
    metadata?: Metadata;
    protocol: string;
    rewards: Balance[];
    stakedAmount: string;
    unlockDate?: Date;
    validator?: string;
    value?: Price;
}

// @public
export interface SyncStatus {
    accountId: string;
    itemsSynced?: number;
    lastError?: string;
    lastSyncTime?: Date;
    metadata?: Metadata;
    source: IntegrationSource;
    status: 'IDLE' | 'SYNCING' | 'SUCCESS' | 'ERROR';
}

// @public
export type TimeRange = {
    start: Date;
    end: Date;
};

// @public
export interface TrackedAddress {
    accountId: AccountId;
    accountLabel: string;
    address: string;
    chainScope: Chain[];
    connectionLabel: string;
    providerId: WalletProviderId | 'watch';
    walletConnectionId: WalletConnectionId | 'watch';
}

// @public
export interface Transaction {
    accountId: string;
    assetsIn?: Array<{
        asset: Asset;
        amount: string;
        value?: Price;
    }>;
    assetsOut?: Array<{
        asset: Asset;
        amount: string;
        value?: Price;
    }>;
    blockNumber?: number;
    chain?: Chain;
    fees?: Array<{
        asset: Asset;
        amount: string;
        value?: Price;
    }>;
    from?: string;
    hash?: string;
    id: string;
    metadata?: Metadata;
    method?: string;
    protocol?: string;
    status: 'PENDING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';
    timestamp: Date;
    to?: string;
    type: TransactionType;
    walletConnectionId?: WalletConnectionId | 'watch';
}

// @public
export enum TransactionType {
    BORROW = "BORROW",
    BURN = "BURN",
    BUY = "BUY",
    CLAIM_REWARD = "CLAIM_REWARD",
    DIVIDEND = "DIVIDEND",
    FEE = "FEE",
    INTEREST = "INTEREST",
    LIQUIDATION = "LIQUIDATION",
    MINT = "MINT",
    OTHER = "OTHER",
    PROVIDE_LIQUIDITY = "PROVIDE_LIQUIDITY",
    REMOVE_LIQUIDITY = "REMOVE_LIQUIDITY",
    REPAY = "REPAY",
    SELL = "SELL",
    STAKE = "STAKE",
    SWAP = "SWAP",
    TRANSFER_IN = "TRANSFER_IN",
    TRANSFER_OUT = "TRANSFER_OUT",
    UNSTAKE = "UNSTAKE"
}

// @public
export interface UserRpcConfig {
    endpoints: UserRpcEndpoint[];
    mode: 'override' | 'prepend';
}

// @public
export interface UserRpcEndpoint {
    chainId: string;
    label?: string;
    url: string;
    wsUrl?: string;
}

// @public
export interface VaultPosition {
    apy?: number;
    chain: Chain;
    depositAsset: Asset;
    depositedAmount: string;
    discoverySource?: DeFiDiscoverySource;
    id: string;
    metadata?: Metadata;
    pricePerShare?: number;
    protocol: string;
    shareBalance?: string;
    strategyType: VaultStrategyType;
    value?: Price;
    vaultAddress: string;
    vaultName: string;
}

// @public
export enum VaultStrategyType {
    LENDING = "LENDING",
    LIQUIDITY_PROVISION = "LIQUIDITY_PROVISION",
    OTHER = "OTHER",
    STRUCTURED_PRODUCT = "STRUCTURED_PRODUCT",
    YIELD_AGGREGATOR = "YIELD_AGGREGATOR"
}

// @public
export interface WalletConnection {
    accounts: ConnectedAccount[];
    activeAccountAddress: string | null;
    connectedAt: string;
    connectionId: WalletConnectionId;
    connectionLabel: string;
    lastActiveAt: string;
    providerIcon: string;
    providerId: WalletProviderId;
    providerName: string;
    sessionStatus: 'active' | 'stale' | 'disconnected';
    supportedChains: Chain[];
}

// @public
export type WalletConnectionId = string;

// @public
export interface WalletPortfolio {
    accounts: AccountPortfolio[];
    connectionLabel: string;
    providerName: string;
    totalValue: Price;
    walletConnectionId: WalletConnectionId;
}

// @public
export type WalletProviderId = 'metamask' | 'rabby' | 'walletconnect' | 'coinbase-wallet' | 'trust-wallet' | 'frame' | 'crypto-com-onchain' | 'phantom' | 'solflare' | 'backpack' | 'exodus' | 'manual';

// @public
export interface WatchAddress {
    accountId: AccountId;
    addedAt: string;
    address: string;
    addressLabel: string;
    chainScope: Chain[];
}

// (No @packageDocumentation comment for this package)

```
